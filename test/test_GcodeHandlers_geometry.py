# coding=utf-8
"""Unit tests for geometry code in the GcodeHandlers class."""

from __future__ import absolute_import

import math
import mock

from octoprint_excluderegion.GcodeHandlers import GcodeHandlers, MM_PER_ARC_SEGMENT

from .utils import TestCase


class GcodeHandlersTests(TestCase):
    """Unit tests for the geometry code in the GcodeHandlers class."""

    @staticmethod
    def _planArcResultIterator(items):
        """Create an iterable for each point pair in the provided items."""
        for index in range(0, len(items), 2):
            yield (items[index], items[index + 1])

    def _assert_planArc_commonResultProperties(
            self, start=None, end=None, center=None, radius=None, items=None
    ):  # pylint: disable=too-many-locals
        """
        Assert several common properties hold for results from the planArc method.

        Parameters
        ----------
        start : pair(float, float)
            The starting point of the arc.  This point is not expected in the items list, unless it
            is identical to the end point.
        end : pair(float, float)
            The ending point of the arc.  This point is expected in the items list.
        center : pair(float, float)
            The center point of the arc.  Each point in the items list will be tested to ensure the
            distance from this point approximately matches the radius.
        radius : float
            The radius of the arc to compare items to.
        items : list of float X/Y coordinate values
            The list of points generated by the planArc method
        """
        assert start is not None
        assert end is not None
        assert center is not None
        assert radius is not None
        assert items is not None

        numItems = len(items)
        self.assertTrue(numItems > 0, "The result should not be an empty list")
        self.assertTrue((numItems & 1) == 0, "The number of items returned should be even")

        (prevX, prevY) = start
        foundStartPoint = False
        index = 0
        point = None

        for point in self._planArcResultIterator(items):
            if (point == start):
                foundStartPoint = True

            (x, y) = point

            distToCenter = math.hypot(center[0] - x, center[1] - y)

            self.assertAlmostEqual(
                distToCenter, radius,
                msg=("The distance from the center point to result point #%s (%s,%s) should " +
                     "match the desired radius (%s != %s)") % (index, x, y, distToCenter, radius)
            )

            distFromPrev = math.hypot(prevX - x, prevY - y)

            self.assertAlmostEqual(
                distFromPrev, MM_PER_ARC_SEGMENT,
                delta=1.0 / (radius * 3),
                msg=(
                    "The distance from point #%s (%s,%s) to point #%s (%s,%s) should be approx " +
                    "MM_PER_ARC_SEGMENT"
                ) % (
                    index - 1, prevX, prevY, index, x, y
                )
            )

            (prevX, prevY) = point
            index += 1

        if (start != end):
            self.assertFalse(
                foundStartPoint,
                "The starting point (%s,%s) should NOT be included" % (start[0], start[1])
            )

        self.assertTrue(
            point == end,
            "The last point in the items should equal the ending point (%s,%s)" % (end[0], end[1])
        )

    def _assert_planArc_axisProperties(  # pylint: disable=too-many-arguments
            self,
            coordinateOffset=None,
            initialValue=None,
            initialDirection=None,
            expectedReversals=None,
            filterFunc=None,
            items=None
    ):
        """
        Assert relationships between the coordinate values for a specific axis.

        Parameters
        ----------
        coordinateOffset : one of 0 or 1
            0 to assert the x axis values, 1 for y axis values.
        initialValue : float
            The initial value for the axis.
        initialDirection : one of 1 (increasing) or -1 (decreasing)
            The initial direction for the axis.
        expectedReversals : non-negative int
            The number of times a direction reversal is expected for the axis.
        filter : function(x, y, direction)
            Additional filter function to apply to each point encountered.
        items : list of float X/Y coordinate values
            The list of points generated by the planArc method
        """
        assert coordinateOffset in (0, 1)
        assert initialValue is not None
        assert initialDirection in (1, -1)
        assert expectedReversals >= 0
        assert items is not None

        numReversals = 0
        prevValue = initialValue
        prevDirection = initialDirection
        index = 0
        for point in self._planArcResultIterator(items):
            value = point[coordinateOffset]

            direction = cmp(value, prevValue)
            self.assertFalse(direction == 0, "The direction should never be 0: index=%s" % index)
            if (direction != prevDirection):
                numReversals += 1

            if (filterFunc is not None):
                filterFunc(point[0], point[1], direction, index)

            prevValue = value
            prevDirection = direction

            index += 1

        self.assertEqual(
            numReversals, expectedReversals,
            "The %s direction should reverse exactly %s time(s)" % (
                "x" if coordinateOffset == 0 else "y",
                expectedReversals
            )
        )

    # TODO: Verify planArc when provided with a negative radius

    def test_planArc_clockwise_semicircle(self):
        """Tests the planArc method with a clockwise semicircular 100 unit arc centered at (0,0)."""
        arcRadius = 50

        mockLogger = mock.Mock()

        mockState = mock.Mock()
        mockState.position.X_AXIS.nativeToLogical.return_value = -arcRadius
        mockState.position.Y_AXIS.nativeToLogical.return_value = 0

        unit = GcodeHandlers(mockState, mockLogger)

        result = unit.planArc(arcRadius, 0, arcRadius, 0, True)

        self._assert_planArc_commonResultProperties(
            start=(-arcRadius, 0),
            end=(arcRadius, 0),
            center=(0, 0),
            radius=arcRadius,
            items=result
        )

        # y value comparisons
        # - the y component of each point should be above or equal to the y axis
        # - the y component direction must change one time
        self._assert_planArc_axisProperties(
            coordinateOffset=1,
            initialValue=0,
            initialDirection=1,
            expectedReversals=1,
            items=result,
            filterFunc=lambda x, y, direction, index: (
                self.assertTrue(
                    y >= 0,
                    "Each y coordinate should be on or above the Y axis" +
                    ": pt=(%s, %s) index=%s" % (x, y, index)
                )
            )
        )

        # x value comparisons
        # - the x component of each point should increase for each point
        self._assert_planArc_axisProperties(
            coordinateOffset=0,
            initialValue=-arcRadius,
            initialDirection=1,
            expectedReversals=0,
            items=result
        )

    def test_planArc_clockwise_circle(self):
        """Tests the planArc method with a clockwise circular 100 unit arc centered at (0,0)."""
        arcRadius = 50

        mockLogger = mock.Mock()

        mockState = mock.Mock()
        mockState.position.X_AXIS.nativeToLogical.return_value = -arcRadius
        mockState.position.Y_AXIS.nativeToLogical.return_value = 0

        unit = GcodeHandlers(mockState, mockLogger)

        result = unit.planArc(-arcRadius, 0, arcRadius, 0, True)

        self._assert_planArc_commonResultProperties(
            start=(-arcRadius, 0),
            end=(-arcRadius, 0),
            center=(0, 0),
            radius=arcRadius,
            items=result
        )

        # y value comparisons
        # - the y component of each point to the left of x axis should have a positive direction
        # - the y component of each point to the right of x axis should have a negative direction
        # - the y component direction must change two times
        ignoredY = {"first": False}

        def filter_y(x, y, direction, index):
            if (x < 0):
                self.assertEqual(
                    direction, 1,
                    "The y direction should be positive for points to the left of the x axis" +
                    ": pt=(%s, %s) index=%s" % (x, y, index)
                )
            elif (ignoredY["first"]):
                self.assertEqual(
                    direction, -1,
                    "The y direction should be negative for points to the right of the x axis" +
                    ": pt=(%s, %s) index=%s" % (x, y, index)
                )
            else:
                # Ignore the first one, since it _could_ have the opposite direction at the boundary
                ignoredY["first"] = True

        self._assert_planArc_axisProperties(
            coordinateOffset=1,
            initialValue=0,
            initialDirection=1,
            expectedReversals=2,
            items=result,
            filterFunc=filter_y
        )

        # x value comparisons
        # - the x component of each point above the y axis should have a positive direction
        # - the x component of each point below the y axis should have a negative direction
        # - the x component direction must change one time
        ignoredX = {"first": False}

        def filter_x(x, y, direction, index):
            if (y > 0):
                self.assertEqual(
                    direction, 1,
                    "The x direction should be positive for points above the y axis" +
                    ": pt=(%s, %s) index=%s" % (x, y, index)
                )
            elif (ignoredX["first"]):
                self.assertEqual(
                    direction, -1,
                    "The x direction should be negative for points below the y axis" +
                    ": pt=(%s, %s) index=%s" % (x, y, index)
                )
            else:
                # Ignore the first one, since it _could_ have the opposite direction at the boundary
                ignoredX["first"] = True

        self._assert_planArc_axisProperties(
            coordinateOffset=0,
            initialValue=-arcRadius,
            initialDirection=1,
            expectedReversals=1,
            items=result,
            filterFunc=filter_x
        )

    def test_planArc_counterClockwise_semicircle(self):
        """Tests the planArc method with a CCW semicircular 100 unit arc centered at (0,0)."""
        arcRadius = 50

        mockLogger = mock.Mock()

        mockState = mock.Mock()
        mockState.position.X_AXIS.nativeToLogical.return_value = -arcRadius
        mockState.position.Y_AXIS.nativeToLogical.return_value = 0

        unit = GcodeHandlers(mockState, mockLogger)

        result = unit.planArc(arcRadius, 0, arcRadius, 0, False)

        self._assert_planArc_commonResultProperties(
            start=(-arcRadius, 0),
            end=(arcRadius, 0),
            center=(0, 0),
            radius=arcRadius,
            items=result
        )

        # y value comparisons
        # - the y component of each point should be below or equal to the y axis
        # - the y component direction must change one time
        self._assert_planArc_axisProperties(
            coordinateOffset=1,
            initialValue=0,
            initialDirection=-1,
            expectedReversals=1,
            items=result,
            filterFunc=lambda x, y, direction, index: (
                self.assertTrue(
                    y <= 0,
                    "Each y coordinate should be on or below the Y axis" +
                    ": pt=(%s, %s) index=%s" % (x, y, index)
                )
            )
        )

        # x value comparisons
        # - the x component of each point should increase for each point
        self._assert_planArc_axisProperties(
            coordinateOffset=0,
            initialValue=-arcRadius,
            initialDirection=1,
            expectedReversals=0,
            items=result
        )

    def test_planArc_counterClockwise_circle(self):
        """Tests the planArc method with a CCW circular 100 unit arc centered at (0,0)."""
        arcRadius = 50

        mockLogger = mock.Mock()

        mockState = mock.Mock()
        mockState.position.X_AXIS.nativeToLogical.return_value = -arcRadius
        mockState.position.Y_AXIS.nativeToLogical.return_value = 0

        unit = GcodeHandlers(mockState, mockLogger)

        result = unit.planArc(-arcRadius, 0, arcRadius, 0, False)

        self._assert_planArc_commonResultProperties(
            start=(-arcRadius, 0),
            end=(-arcRadius, 0),
            center=(0, 0),
            radius=arcRadius,
            items=result
        )

        # y value comparisons
        # - the y component of each point to the left of x axis should have a negative direction
        # - the y component of each point to the right of x axis should have a positive direction
        # - the y component direction must change two times
        ignoredY = {"first": False}

        def filter_y(x, y, direction, index):
            if (x < 0):
                self.assertEqual(
                    direction, -1,
                    "The y direction should be negative for points to the left of the x axis" +
                    ": pt=(%s, %s) index=%s" % (x, y, index)
                )
            elif (ignoredY["first"]):
                self.assertEqual(
                    direction, 1,
                    "The y direction should be positive for points to the right of the x axis" +
                    ": pt=(%s, %s) index=%s" % (x, y, index)
                )
            else:
                # Ignore the first one, since it _could_ have the opposite direction at the boundary
                ignoredY["first"] = True

        self._assert_planArc_axisProperties(
            coordinateOffset=1,
            initialValue=0,
            initialDirection=-1,
            expectedReversals=2,
            items=result,
            filterFunc=filter_y
        )

        # x value comparisons
        # - the x component of each point above the y axis should have a negative direction
        # - the x component of each point below the y axis should have a positive direction
        # - the x component direction must change one time
        ignoredX = {"first": False}

        def filter_x(x, y, direction, index):
            if (y < 0):
                self.assertEqual(
                    direction, 1,
                    "The x direction should be positive for points below the y axis" +
                    ": pt=(%s, %s) index=%s" % (x, y, index)
                )
            elif (ignoredX["first"]):
                self.assertEqual(
                    direction, -1,
                    "The x direction should be negative for points above the y axis" +
                    ": pt=(%s, %s) index=%s" % (x, y, index)
                )
            else:
                # Ignore the first one, since it _could_ have the opposite direction at the boundary
                ignoredX["first"] = True

        self._assert_planArc_axisProperties(
            coordinateOffset=0,
            initialValue=-arcRadius,
            initialDirection=1,
            expectedReversals=1,
            items=result,
            filterFunc=filter_x
        )

    def test_computeArcCenterOffsets_positiveRadius(self):
        """Test computeArcCenterOffsets method with a positive radius value."""
        # Tests an arc with a chord length of 8 (half-width of 4) and a height (from chord to
        # center point on arc) of 3

        arcRadius = 4.0 + 1.0/6.0

        mockLogger = mock.Mock()

        mockState = mock.Mock()
        mockState.position.X_AXIS.nativeToLogical.return_value = 0
        mockState.position.Y_AXIS.nativeToLogical.return_value = 0

        unit = GcodeHandlers(mockState, mockLogger)

        result = unit.computeArcCenterOffsets(4 * 2, 0, arcRadius, True)

        self.assertEqual(
            result[0], 4,
            "The returned I value should match the expected value"
        )
        self.assertAlmostEqual(
            result[1],
            arcRadius - 3,  # Note subtraction here when radius is positive
            msg="The returned J value should match the expected value"
        )

    def test_computeArcCenterOffsets_negativeRadius(self):
        """Test computeArcCenterOffsets method with a negative radius value."""
        # Tests an arc with a chord length of 8 (half-width of 4) and a height (from chord to
        # center point on arc) of 3

        arcRadius = -(4.0 + 1.0/6.0)

        mockLogger = mock.Mock()

        mockState = mock.Mock()
        mockState.position.X_AXIS.nativeToLogical.return_value = 0
        mockState.position.Y_AXIS.nativeToLogical.return_value = 0

        unit = GcodeHandlers(mockState, mockLogger)

        result = unit.computeArcCenterOffsets(8, 0, arcRadius, True)

        self.assertEqual(
            result[0], 4,
            "The returned I value should match the expected value"
        )
        self.assertAlmostEqual(
            result[1],
            arcRadius + 3,  # Note addition here when radius is negative
            msg="The returned J value should match the expected value"
        )

    def test_computeArcCenterOffsets_zeroRadius(self):
        """Test the computeArcCenterOffsets method with a radius of zero."""
        mockLogger = mock.Mock()

        mockState = mock.Mock()
        mockState.position.X_AXIS.nativeToLogical.return_value = 0
        mockState.position.Y_AXIS.nativeToLogical.return_value = 0

        unit = GcodeHandlers(mockState, mockLogger)

        result = unit.computeArcCenterOffsets(10, 10, 0, True)

        self.assertEqual(result, (0, 0), "No offset should be computed when the radius is 0")

    def test_computeArcCenterOffsets_circle(self):
        """Test the computeArcCenterOffsets method when the start and end points are identical."""
        arcRadius = 50
        mockLogger = mock.Mock()

        mockState = mock.Mock()
        mockState.position.X_AXIS.nativeToLogical.return_value = 0
        mockState.position.Y_AXIS.nativeToLogical.return_value = 0

        unit = GcodeHandlers(mockState, mockLogger)

        result = unit.computeArcCenterOffsets(0, 0, arcRadius, True)

        self.assertEqual(
            result, (0, 0),
            "No offset should be computed when the start and end points are the same"
        )

    def test_computeArcCenterOffsets_clockwise_semicircle(self):
        """Test the computeArcCenterOffsets method with a clockwise semicircular 100 unit arc."""
        arcRadius = 50

        mockLogger = mock.Mock()

        mockState = mock.Mock()
        mockState.position.X_AXIS.nativeToLogical.return_value = -arcRadius
        mockState.position.Y_AXIS.nativeToLogical.return_value = 0

        unit = GcodeHandlers(mockState, mockLogger)

        result = unit.computeArcCenterOffsets(arcRadius, 0, arcRadius, True)

        self.assertEqual(
            result, (arcRadius, 0),
            "The computed center offset should be (%s, %s)" % (arcRadius, 0)
        )

    def test_computeArcCenterOffsets_counterClockwise_semicircle(self):
        """Test the computeArcCenterOffsets method with a CCW semicircular 100 unit arc."""
        arcRadius = 50

        mockLogger = mock.Mock()

        mockState = mock.Mock()
        mockState.position.X_AXIS.nativeToLogical.return_value = arcRadius
        mockState.position.Y_AXIS.nativeToLogical.return_value = 0

        unit = GcodeHandlers(mockState, mockLogger)

        result = unit.computeArcCenterOffsets(-arcRadius, 0, arcRadius, False)

        self.assertEqual(
            result, (-arcRadius, 0),
            "The computed center offset should be (%s, %s)" % (-arcRadius, 0)
        )
